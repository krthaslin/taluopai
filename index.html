<script>
        const cardRing = document.getElementById('card-ring');
        const introUi = document.getElementById('intro-ui');
        const mainBg = document.getElementById('main-bg');
        const isMobile = window.innerWidth < 768;
        const TOTAL_CARDS = isMobile ? 12 : 24; 
        
        let allCards = [];
        let pendingAiResult = null; 
        let activeFlippedCard = null; 

        // 你的图片资源
        const SKINS = {
            MOON: "[https://raw.githubusercontent.com/krthaslin/taluopai/main/card/moon.png](https://raw.githubusercontent.com/krthaslin/taluopai/main/card/moon.png)", 
            STAR: "[https://raw.githubusercontent.com/krthaslin/taluopai/main/card/star.png](https://raw.githubusercontent.com/krthaslin/taluopai/main/card/star.png)", 
            SUN:  "[https://raw.githubusercontent.com/krthaslin/taluopai/main/card/sun.png](https://raw.githubusercontent.com/krthaslin/taluopai/main/card/sun.png)"  
        };

        // 错误弹窗逻辑
        function showError(msg) {
            const modal = document.getElementById('error-modal');
            const text = document.getElementById('error-text');
            if(modal && text) {
                modal.style.display = 'flex';
                text.innerText = msg;
            } else {
                alert("系统错误: " + msg);
            }
        }

        async function preFetchAiResult(query) {
            try {
                const response = await fetch('/api/tarot', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query: query })
                });
                
                const jsonResp = await response.json();

                if (response.status !== 200) {
                    throw new Error(`API 报错 (${response.status}): ${jsonResp.error || '未知错误'}`);
                }

                // 这里是兼容逻辑：后端现在会返回 { result: {...} }
                // 但为了保险，我们还是做一次判断
                let finalData = jsonResp.result || jsonResp;

                // 如果后端解析失败传回了 raw 字符串，前端再试一次（三重保险）
                if (!finalData.title && typeof jsonResp.debug_raw === 'string') {
                    try {
                        const raw = jsonResp.debug_raw;
                        const start = raw.indexOf('{');
                        const end = raw.lastIndexOf('}');
                        if(start !== -1 && end !== -1) {
                            finalData = JSON.parse(raw.substring(start, end + 1));
                        }
                    } catch(e) {
                        console.error("前端补救解析失败");
                    }
                }

                // 最终检查数据有效性
                if (!finalData || !finalData.title) {
                    throw new Error("数据格式依然不正确，AI 可能在神游。");
                }

                pendingAiResult = finalData;

                if (activeFlippedCard) {
                    renderCardContent(activeFlippedCard, finalData);
                }

            } catch (e) {
                console.error(e);
                showError(e.message); 
                
                // 失败状态卡片
                pendingAiResult = {
                    id: "ERR",
                    title: "连接中断",
                    enTitle: "CONNECTION LOST",
                    desc: "命运的信号被干扰，请稍后重试。"
                };
                if (activeFlippedCard) renderCardContent(activeFlippedCard, pendingAiResult);
            }
        }

        function startRitual() {
            const query = document.getElementById('user-input').value;
            if(!query) return alert("心诚则灵...");
            introUi.classList.add('hidden');
            preFetchAiResult(query);
            generateVortex();
        }

        function generateVortex() {
            const radius = isMobile ? 220 : 550; 
            const zPush = isMobile ? -350 : 0; 
            const yJitter = isMobile ? 180 : 300; 
            if(isMobile) cardRing.style.transform = `translateZ(${zPush}px)`;

            for(let i=0; i<TOTAL_CARDS; i++) {
                const card = document.createElement('div');
                card.className = 'tarot-card';
                card.innerHTML = `<div class="face back"></div><div class="face front"><div class="content-overlay"></div></div>`;
                card.style.transform = `translate3d(0, 800px, -2000px)`; 
                cardRing.appendChild(card);
                allCards.push(card);

                setTimeout(() => {
                    const angle = (360 / TOTAL_CARDS) * i;
                    const randomY = (Math.random() - 0.5) * yJitter; 
                    card.style.opacity = 1;
                    card.style.transform = `rotateY(${angle}deg) translateZ(${radius}px) translateY(${randomY}px)`;
                }, 100 + (i * 30));
            }
            setTimeout(performSelection, 3000);
        }

        function performSelection() {
            const step = Math.floor(TOTAL_CARDS / 3);
            const indices = [0, step, step * 2];
            const chosenCards = indices.map(i => allCards[i]);

            allCards.forEach((card, idx) => { if(!indices.includes(idx)) card.classList.add('vanish'); });
            chosenCards.forEach((card) => {
                card.style.transition = 'transform 0.4s ease-in'; 
                card.style.transform = `translate3d(0, 0, -2000px) rotateY(0deg)`;
            });

            setTimeout(() => {
                chosenCards.forEach((card, i) => {
                    const spread = isMobile ? 130 : 200;
                    let xPos = 0; if(i === 0) xPos = -spread; if(i === 2) xPos = spread;
                    card.offsetHeight; 
                    card.className = 'tarot-card chosen'; 
                    let rotY = 0; if(i === 0) rotY = 10; if(i === 2) rotY = -10;

                    const zPop = isMobile ? 120 : 200; 
                    card.style.transform = `translate3d(${xPos}px, ${isMobile?-50:0}px, ${zPop}px) rotateY(${rotY}deg) scale(1.0)`;
                    
                    const backFace = card.querySelector('.face.back');
                    const frontFace = card.querySelector('.face.front');
                    let skinUrl = [SKINS.MOON, SKINS.STAR, SKINS.SUN][i];
                    
                    const img = new Image();
                    img.onload = () => {
                        backFace.classList.add('has-skin');
                        backFace.style.backgroundImage = `url('${skinUrl}')`;
                        frontFace.style.backgroundImage = `url('${skinUrl}')`;
                    };
                    img.src = skinUrl;
                    card.onclick = () => revealContent(card);
                });
            }, 500); 
        }

        function renderCardContent(card, data) {
            const overlay = card.querySelector('.content-overlay');
            const frontFace = card.querySelector('.face.front');
            
            const roman = data.id || "??";
            const title = data.title || "未知";
            const enTitle = data.enTitle || "";
            const desc = data.desc || "......";

            overlay.innerHTML = `
                <div class="title-group">
                    <span class="roman-num">${roman}</span>
                    <h3 class="main-title">${title}</h3>
                    <span class="sub-title">${enTitle}</span>
                </div>
                <p class="desc-text">${desc}</p>
            `;
            frontFace.classList.add('loaded');
        }

        function revealContent(card) {
            if(card.classList.contains('flipped')) return;
            activeFlippedCard = card; 
            mainBg.style.opacity = '0.3'; 
            document.querySelectorAll('.chosen').forEach(c => { if(c !== card) { c.style.opacity = 0; c.style.pointerEvents = 'none'; }});

            if (pendingAiResult) {
                renderCardContent(card, pendingAiResult);
            } else {
                const overlay = card.querySelector('.content-overlay');
                const frontFace = card.querySelector('.face.front');
                overlay.innerHTML = `
                    <div class="title-group">
                        <span class="roman-num">...</span>
                        <h3 class="main-title">连接中</h3>
                        <span class="sub-title">CONNECTING</span>
                    </div>
                    <p class="desc-text" style="text-align:center">正在建立量子链接...</p>
                `;
                frontFace.classList.add('loaded');
            }
            card.classList.add('flipped');
        }
    </script>
